#!/usr/bin/env python3
"""
üîÑ BINANCE HISTORICAL SYNC - Sincronizador de Datos Hist√≥ricos
Sincroniza datos hist√≥ricos de la cuenta de Binance con la base de datos local
"""

import asyncio
import aiohttp
import hmac
import hashlib
import time
import json
import os
from datetime import datetime, timezone, timedelta
from decimal import Decimal
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
import pandas as pd
from trading_database import TradingDatabase
from dotenv import load_dotenv

load_dotenv()

@dataclass
class BinanceConfig:
    """üîß Configuraci√≥n de Binance API"""
    api_key: str = ""
    secret_key: str = ""
    testnet: bool = True
    base_url: str = ""
    
    def __post_init__(self):
        self.api_key = self.api_key or os.getenv('BINANCE_API_KEY', '').strip('"')
        self.secret_key = self.secret_key or os.getenv('BINANCE_API_SECRET', '').strip('"') or os.getenv('BINANCE_SECRET_KEY', '').strip('"')
        
        if self.testnet:
            self.base_url = "https://testnet.binance.vision"
        else:
            self.base_url = "https://api.binance.com"

class BinanceHistoricalSync:
    """üîÑ Sincronizador de datos hist√≥ricos de Binance"""
    
    def __init__(self, config: BinanceConfig = None):
        self.config = config or BinanceConfig()
        self.db = TradingDatabase()
        self.session = None
        
        print(f"üîÑ Inicializando sincronizador de Binance")
        print(f"   üì° URL: {self.config.base_url}")
        print(f"   üîë API Key: {'‚úÖ Configurada' if self.config.api_key else '‚ùå No configurada'}")
        
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    def _generate_signature(self, query_string: str) -> str:
        """üîê Generar firma HMAC para autenticaci√≥n"""
        return hmac.new(
            self.config.secret_key.encode('utf-8'),
            query_string.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
    
    def _get_headers(self) -> Dict[str, str]:
        """üìã Headers para requests autenticados"""
        return {
            'X-MBX-APIKEY': self.config.api_key,
            'Content-Type': 'application/json'
        }
    
    async def get_account_info(self) -> Dict:
        """üí∞ Obtener informaci√≥n completa de la cuenta"""
        print("üí∞ Obteniendo informaci√≥n de la cuenta...")
        
        timestamp = int(time.time() * 1000)
        query_string = f"timestamp={timestamp}"
        signature = self._generate_signature(query_string)
        
        url = f"{self.config.base_url}/api/v3/account"
        params = {
            'timestamp': timestamp,
            'signature': signature
        }
        
        try:
            async with self.session.get(url, headers=self._get_headers(), params=params) as response:
                if response.status == 200:
                    account_data = await response.json()
                    print(f"‚úÖ Informaci√≥n de cuenta obtenida")
                    print(f"   üìÖ Can Trade: {account_data.get('canTrade', False)}")
                    print(f"   üìà Can Withdraw: {account_data.get('canWithdraw', False)}")
                    print(f"   üíé Account Type: {account_data.get('accountType', 'UNKNOWN')}")
                    
                    # Mostrar balances principales
                    balances = account_data.get('balances', [])
                    significant_balances = [b for b in balances if float(b['free']) > 0 or float(b['locked']) > 0]
                    
                    print(f"üí∞ Balances activos encontrados: {len(significant_balances)}")
                    for balance in significant_balances[:10]:  # Mostrar solo los primeros 10
                        total = float(balance['free']) + float(balance['locked'])
                        print(f"   üíµ {balance['asset']}: {total:.8f} (libre: {balance['free']}, bloqueado: {balance['locked']})")
                    
                    return account_data
                else:
                    error_text = await response.text()
                    print(f"‚ùå Error obteniendo cuenta: {response.status} - {error_text}")
                    return {}
        except Exception as e:
            print(f"‚ùå Excepci√≥n obteniendo cuenta: {e}")
            return {}
    
    async def get_historical_trades(self, symbol: str, days_back: int = 30) -> List[Dict]:
        """üìà Obtener historial de trades de un s√≠mbolo"""
        print(f"üìà Obteniendo historial de trades para {symbol} ({days_back} d√≠as)...")
        
        # Calcular timestamps
        end_time = int(time.time() * 1000)
        start_time = end_time - (days_back * 24 * 60 * 60 * 1000)
        
        timestamp = int(time.time() * 1000)
        query_string = f"symbol={symbol}&startTime={start_time}&endTime={end_time}&timestamp={timestamp}"
        signature = self._generate_signature(query_string)
        
        url = f"{self.config.base_url}/api/v3/myTrades"
        params = {
            'symbol': symbol,
            'startTime': start_time,
            'endTime': end_time,
            'timestamp': timestamp,
            'signature': signature
        }
        
        try:
            async with self.session.get(url, headers=self._get_headers(), params=params) as response:
                if response.status == 200:
                    trades = await response.json()
                    print(f"‚úÖ {len(trades)} trades hist√≥ricos obtenidos para {symbol}")
                    return trades
                else:
                    error_text = await response.text()
                    print(f"‚ùå Error obteniendo trades de {symbol}: {response.status} - {error_text}")
                    return []
        except Exception as e:
            print(f"‚ùå Excepci√≥n obteniendo trades de {symbol}: {e}")
            return []
    
    async def get_deposit_history(self, days_back: int = 90) -> List[Dict]:
        """üí≥ Obtener historial de dep√≥sitos"""
        print(f"üí≥ Obteniendo historial de dep√≥sitos ({days_back} d√≠as)...")
        
        # Calcular timestamps
        end_time = int(time.time() * 1000)
        start_time = end_time - (days_back * 24 * 60 * 60 * 1000)
        
        timestamp = int(time.time() * 1000)
        query_string = f"startTime={start_time}&endTime={end_time}&timestamp={timestamp}"
        signature = self._generate_signature(query_string)
        
        url = f"{self.config.base_url}/sapi/v1/capital/deposit/hisrec"
        params = {
            'startTime': start_time,
            'endTime': end_time,
            'timestamp': timestamp,
            'signature': signature
        }
        
        try:
            async with self.session.get(url, headers=self._get_headers(), params=params) as response:
                if response.status == 200:
                    deposits = await response.json()
                    print(f"‚úÖ {len(deposits)} dep√≥sitos hist√≥ricos obtenidos")
                    return deposits
                else:
                    error_text = await response.text()
                    print(f"‚ùå Error obteniendo dep√≥sitos: {response.status} - {error_text}")
                    return []
        except Exception as e:
            print(f"‚ùå Excepci√≥n obteniendo dep√≥sitos: {e}")
            return []
    
    async def sync_balance_to_database(self, account_info: Dict) -> bool:
        """üíæ Sincronizar balance actual con la base de datos"""
        print("üíæ Sincronizando balance con base de datos...")
        
        try:
            balances = account_info.get('balances', [])
            usdt_balance = 0.0
            total_balance_usd = 0.0
            
            # Calcular balance USDT principal
            for balance in balances:
                if balance['asset'] == 'USDT':
                    usdt_balance = float(balance['free']) + float(balance['locked'])
                    total_balance_usd = usdt_balance  # Por simplicidad, usar USDT como base
                    break
            
            # Crear m√©trica de performance inicial
            performance_data = {
                'timestamp': datetime.now(timezone.utc),
                'total_balance': total_balance_usd,
                'daily_pnl': 0.0,
                'total_pnl': 0.0,
                'daily_return_percent': 0.0,
                'total_return_percent': 0.0,
                'current_drawdown': 0.0,
                'max_drawdown': 0.0,
                'sharpe_ratio': None,
                'win_rate': 0.0,
                'profit_factor': None,
                'active_positions_count': 0,
                'total_exposure_usd': 0.0,
                'exposure_percent': 0.0,
                'trades_today': 0,
                'avg_trade_duration_minutes': None
            }
            
            await self.db.save_performance_metrics(performance_data)
            
            # Log del evento
            await self.db.log_event(
                level="INFO",
                category="SYNC",
                message=f"Balance inicial sincronizado: ${total_balance_usd:.2f} USDT",
                metadata={
                    'sync_type': 'initial_balance',
                    'total_assets': len([b for b in balances if float(b['free']) > 0 or float(b['locked']) > 0]),
                    'account_type': account_info.get('accountType', 'UNKNOWN'),
                    'can_trade': account_info.get('canTrade', False)
                }
            )
            
            print(f"‚úÖ Balance sincronizado: ${total_balance_usd:.2f} USDT")
            return True
            
        except Exception as e:
            print(f"‚ùå Error sincronizando balance: {e}")
            return False
    
    async def sync_historical_trades_to_database(self, symbol: str, historical_trades: List[Dict]) -> int:
        """üìä Sincronizar trades hist√≥ricos con la base de datos"""
        print(f"üìä Sincronizando trades hist√≥ricos de {symbol}...")
        
        synced_count = 0
        
        try:
            for trade in historical_trades:
                # Convertir trade de Binance a formato interno
                trade_data = {
                    'symbol': trade['symbol'],
                    'side': 'BUY' if trade['isBuyer'] else 'SELL',
                    'quantity': float(trade['qty']),
                    'entry_price': float(trade['price']),
                    'entry_time': datetime.fromtimestamp(trade['time'] / 1000, timezone.utc),
                    'exit_time': None,  # Los trades de Binance son instant√°neos
                    'pnl_percent': None,
                    'pnl_usd': None,
                    'stop_loss': None,
                    'take_profit': None,
                    'exit_reason': 'FILLED',
                    'confidence': 1.0,  # Trade hist√≥rico ya ejecutado
                    'strategy': 'HISTORICAL_SYNC',
                    'is_active': False,  # Trade ya completado
                    'metadata': {
                        'binance_trade_id': trade['id'],
                        'commission': trade['commission'],
                        'commission_asset': trade['commissionAsset'],
                        'is_maker': trade['isMaker'],
                        'quote_qty': trade['quoteQty'],
                        'sync_source': 'binance_historical'
                    }
                }
                
                # Guardar en base de datos
                trade_id = await self.db.save_trade(trade_data)
                if trade_id:
                    synced_count += 1
                
                # Peque√±a pausa para evitar sobrecarga
                await asyncio.sleep(0.1)
            
            print(f"‚úÖ {synced_count}/{len(historical_trades)} trades hist√≥ricos sincronizados para {symbol}")
            return synced_count
            
        except Exception as e:
            print(f"‚ùå Error sincronizando trades hist√≥ricos de {symbol}: {e}")
            return synced_count
    
    async def calculate_initial_pnl(self, historical_trades: List[Dict]) -> Dict:
        """üíπ Calcular PnL inicial basado en trades hist√≥ricos"""
        print("üíπ Calculando PnL inicial...")
        
        try:
            if not historical_trades:
                return {'total_pnl': 0.0, 'total_volume': 0.0, 'trade_count': 0}
            
            total_buy_value = 0.0
            total_sell_value = 0.0
            total_commission = 0.0
            total_volume = 0.0
            
            for trade in historical_trades:
                qty = float(trade['qty'])
                price = float(trade['price'])
                commission = float(trade['commission'])
                value = qty * price
                total_volume += value
                total_commission += commission
                
                if trade['isBuyer']:
                    total_buy_value += value
                else:
                    total_sell_value += value
            
            # PnL simple (ventas - compras - comisiones)
            total_pnl = total_sell_value - total_buy_value - total_commission
            
            pnl_summary = {
                'total_pnl': total_pnl,
                'total_volume': total_volume,
                'total_commission': total_commission,
                'trade_count': len(historical_trades),
                'buy_value': total_buy_value,
                'sell_value': total_sell_value
            }
            
            print(f"üíπ PnL calculado: ${total_pnl:.2f} (volumen: ${total_volume:.2f})")
            return pnl_summary
            
        except Exception as e:
            print(f"‚ùå Error calculando PnL: {e}")
            return {'total_pnl': 0.0, 'total_volume': 0.0, 'trade_count': 0}
    
    async def full_sync(self, trading_symbols: List[str] = None, days_back: int = 30) -> Dict:
        """üîÑ Sincronizaci√≥n completa de datos hist√≥ricos"""
        if trading_symbols is None:
            trading_symbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT']
        
        print("üîÑ INICIANDO SINCRONIZACI√ìN COMPLETA")
        print("=" * 50)
        
        sync_results = {
            'success': False,
            'balance_synced': False,
            'symbols_synced': [],
            'total_trades_synced': 0,
            'total_pnl': 0.0,
            'errors': []
        }
        
        try:
            # 1. Verificar API keys
            if not self.config.api_key or not self.config.secret_key:
                error_msg = "‚ùå API keys no configuradas"
                print(error_msg)
                sync_results['errors'].append(error_msg)
                return sync_results
            
            # 2. Obtener informaci√≥n de cuenta
            print("\nüìã PASO 1: Informaci√≥n de cuenta")
            account_info = await self.get_account_info()
            if not account_info:
                error_msg = "‚ùå No se pudo obtener informaci√≥n de cuenta"
                sync_results['errors'].append(error_msg)
                return sync_results
            
            # 3. Sincronizar balance
            print("\nüí∞ PASO 2: Sincronizaci√≥n de balance")
            balance_synced = await self.sync_balance_to_database(account_info)
            sync_results['balance_synced'] = balance_synced
            
            # 4. Sincronizar trades hist√≥ricos por s√≠mbolo
            print("\nüìà PASO 3: Sincronizaci√≥n de trades hist√≥ricos")
            all_historical_trades = []
            
            for symbol in trading_symbols:
                print(f"\nüîç Procesando {symbol}...")
                historical_trades = await self.get_historical_trades(symbol, days_back)
                
                if historical_trades:
                    synced_count = await self.sync_historical_trades_to_database(symbol, historical_trades)
                    sync_results['symbols_synced'].append({
                        'symbol': symbol,
                        'trades_count': len(historical_trades),
                        'synced_count': synced_count
                    })
                    sync_results['total_trades_synced'] += synced_count
                    all_historical_trades.extend(historical_trades)
                else:
                    print(f"‚ö†Ô∏è  No se encontraron trades hist√≥ricos para {symbol}")
            
            # 5. Calcular m√©tricas iniciales
            print("\nüíπ PASO 4: C√°lculo de m√©tricas")
            pnl_summary = await self.calculate_initial_pnl(all_historical_trades)
            sync_results['total_pnl'] = pnl_summary['total_pnl']
            
            # 6. Log de finalizaci√≥n
            await self.db.log_event(
                level="INFO",
                category="SYNC",
                message=f"Sincronizaci√≥n hist√≥rica completada: {sync_results['total_trades_synced']} trades, PnL: ${pnl_summary['total_pnl']:.2f}",
                metadata={
                    'sync_type': 'full_historical',
                    'symbols_processed': len(trading_symbols),
                    'days_back': days_back,
                    'total_volume': pnl_summary['total_volume'],
                    'total_commission': pnl_summary.get('total_commission', 0)
                }
            )
            
            sync_results['success'] = True
            
            print("\n‚úÖ SINCRONIZACI√ìN COMPLETA FINALIZADA")
            print("=" * 50)
            print(f"üí∞ Balance sincronizado: {'‚úÖ' if balance_synced else '‚ùå'}")
            print(f"üìä Symbols procesados: {len(sync_results['symbols_synced'])}")
            print(f"üìà Trades sincronizados: {sync_results['total_trades_synced']}")
            print(f"üíπ PnL total calculado: ${sync_results['total_pnl']:.2f}")
            
            return sync_results
            
        except Exception as e:
            error_msg = f"‚ùå Error en sincronizaci√≥n completa: {e}"
            print(error_msg)
            sync_results['errors'].append(error_msg)
            return sync_results

async def main():
    """üöÄ Funci√≥n principal de sincronizaci√≥n"""
    print("üîÑ BINANCE HISTORICAL SYNC")
    print("=" * 50)
    
    # Configuraci√≥n - USANDO PRODUCCI√ìN
    config = BinanceConfig(
        testnet=False,  # üî¥ PRODUCCI√ìN - Cuenta real
    )
    
    # S√≠mbolos a sincronizar
    trading_symbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT']
    days_back = 30  # √öltimos 30 d√≠as
    
    print(f"üéØ Configuraci√≥n:")
    print(f"   üì° Entorno: {'Testnet' if config.testnet else 'Producci√≥n'}")
    print(f"   üí± S√≠mbolos: {', '.join(trading_symbols)}")
    print(f"   üìÖ D√≠as atr√°s: {days_back}")
    print(f"   üîë API configurada: {'‚úÖ' if config.api_key else '‚ùå'}")
    
    if not config.api_key:
        print("\n‚ùå ERROR: Configura las variables de entorno:")
        print("   export BINANCE_API_KEY='tu_api_key'")
        print("   export BINANCE_API_SECRET='tu_api_secret'")
        return
    
    # Ejecutar sincronizaci√≥n
    async with BinanceHistoricalSync(config) as sync:
        results = await sync.full_sync(trading_symbols, days_back)
        
        if results['success']:
            print(f"\nüéâ SINCRONIZACI√ìN EXITOSA!")
            print(f"   ‚úÖ Balance: {'Sincronizado' if results['balance_synced'] else 'Error'}")
            print(f"   üìä Trades: {results['total_trades_synced']} sincronizados")
            print(f"   üíπ PnL: ${results['total_pnl']:.2f}")
        else:
            print(f"\n‚ùå SINCRONIZACI√ìN CON ERRORES:")
            for error in results['errors']:
                print(f"   ‚ùå {error}")

if __name__ == "__main__":
    asyncio.run(main()) 