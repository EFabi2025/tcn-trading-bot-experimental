#!/usr/bin/env python3
"""
üéØ ETH TRADING READY - Modelo ETH que predice BUY, HOLD, SELL para trading real
REQUISITOS M√çNIMOS CUMPLIDOS PARA TRADING
"""

import numpy as np
import pandas as pd
import tensorflow as tf
from binance.client import Client as BinanceClient
from sklearn.preprocessing import StandardScaler
from sklearn.utils.class_weight import compute_class_weight
from collections import Counter
import pickle
import json
import os
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

class ETHTradingReady:
    """Modelo ETH optimizado para trading real con las 3 se√±ales"""
    
    def __init__(self):
        self.pair_symbol = "ETHUSDT"
        self.pair_name = "ETH"
        self.class_names = ['SELL', 'HOLD', 'BUY']
        
        # PAR√ÅMETROS OPTIMIZADOS PARA 3 SE√ëALES
        self.volatility_threshold = 0.004  # 0.4% - m√°s sensible para capturar BUY
        self.prediction_periods = 2        # 10 min - m√°s inmediato
        self.min_samples_per_class = 15    # M√≠nimo por clase
        
        print("üéØ ETH TRADING READY")
        print("="*50)
        print(f"üìä Par: {self.pair_symbol}")
        print(f"üéØ Threshold: {self.volatility_threshold*100:.1f}%")
        print(f"‚è∞ Predicci√≥n: {self.prediction_periods} per√≠odos (10 min)")
        print(f"üìã Objetivo: PREDECIR BUY, HOLD, SELL")
        print("üöÄ TRADING READY!")
    
    def get_optimized_data(self):
        """Obtener datos optimizados para 3 se√±ales"""
        try:
            print(f"\nüìã DATOS OPTIMIZADOS PARA 3 SE√ëALES")
            print("-" * 40)
            
            client = BinanceClient()
            ticker = client.get_symbol_ticker(symbol=self.pair_symbol)
            price = float(ticker['price'])
            print(f"‚úÖ Precio ETH: ${price:,.2f}")
            
            # M√°s datos hist√≥ricos para mejor balance
            klines = client.get_historical_klines(
                symbol=self.pair_symbol,
                interval='5m',
                limit=500  # M√°s datos
            )
            
            df = pd.DataFrame(klines, columns=[
                'timestamp', 'open', 'high', 'low', 'close', 'volume',
                'close_time', 'quote_asset_volume', 'number_of_trades',
                'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'ignore'
            ])
            
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            for col in ['open', 'high', 'low', 'close', 'volume']:
                df[col] = pd.to_numeric(df[col], errors='coerce')
            
            df = df.dropna()
            print(f"‚úÖ {len(df)} per√≠odos obtenidos")
            
            # === FEATURES ESPEC√çFICAS PARA TRADING ===
            print("üîß Features espec√≠ficas para trading...")
            
            # 1. Returns m√∫ltiples timeframes
            df['returns_1'] = df['close'].pct_change(1)
            df['returns_3'] = df['close'].pct_change(3)
            df['returns_5'] = df['close'].pct_change(5)
            
            # 2. Momentum indicators
            df['sma_5'] = df['close'].rolling(5).mean()
            df['sma_20'] = df['close'].rolling(20).mean()
            df['momentum_5_20'] = (df['sma_5'] - df['sma_20']) / df['sma_20']
            
            # 3. RSI
            delta = df['close'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            rs = gain / loss
            df['rsi'] = 100 - (100 / (1 + rs))
            df['rsi_norm'] = (df['rsi'] - 50) / 50  # Normalizado -1 a 1
            
            # 4. MACD
            ema_12 = df['close'].ewm(span=12).mean()
            ema_26 = df['close'].ewm(span=26).mean()
            df['macd'] = (ema_12 - ema_26) / df['close']
            
            # 5. Bollinger position
            ma_20 = df['close'].rolling(20).mean()
            std_20 = df['close'].rolling(20).std()
            df['bb_position'] = (df['close'] - ma_20) / (2 * std_20)
            
            # 6. Volume indicators
            df['volume_ma'] = df['volume'].rolling(10).mean()
            df['volume_surge'] = df['volume'] / df['volume_ma']
            
            # 7. Price velocity
            df['price_velocity'] = df['close'].diff().rolling(3).mean()
            
            # 8. Volatility
            df['volatility'] = df['returns_1'].rolling(10).std()
            
            # Features finales
            self.features = [
                'returns_1', 'returns_3', 'momentum_5_20', 'rsi_norm', 
                'macd', 'bb_position', 'volume_surge', 'volatility'
            ]
            
            df = df.dropna()
            print(f"‚úÖ Features trading: {len(self.features)}")
            print(f"‚úÖ Datos finales: {len(df)} per√≠odos")
            
            return df
            
        except Exception as e:
            print(f"‚ùå Error: {e}")
            return None
    
    def create_balanced_labels(self, df):
        """Crear labels balanceadas para las 3 se√±ales"""
        try:
            print(f"\nüìã LABELS BALANCEADAS PARA 3 SE√ëALES")
            print("-" * 40)
            
            threshold = self.volatility_threshold
            pred_periods = self.prediction_periods
            
            print(f"üéØ Threshold: {threshold*100:.1f}%")
            print(f"‚è∞ Predicci√≥n: {pred_periods} per√≠odos")
            
            labels = []
            
            # Analizar rangos de cambio para optimizar thresholds
            changes = []
            for i in range(len(df) - pred_periods):
                current = df['close'].iloc[i]
                future = df['close'].iloc[i + pred_periods]
                change = (future - current) / current
                changes.append(change)
            
            changes = np.array(changes)
            
            # Estad√≠sticas de cambios
            print(f"üìä Estad√≠sticas de cambios:")
            print(f"   Min: {np.min(changes)*100:.2f}%")
            print(f"   Max: {np.max(changes)*100:.2f}%")
            print(f"   Mean: {np.mean(changes)*100:.2f}%")
            print(f"   Std: {np.std(changes)*100:.2f}%")
            
            # Ajustar threshold din√°micamente si es necesario
            std_changes = np.std(changes)
            if threshold < std_changes * 0.5:
                threshold = std_changes * 0.6
                print(f"üîß Threshold ajustado a: {threshold*100:.1f}%")
            
            # Crear labels
            for change in changes:
                if change < -threshold:
                    labels.append(0)  # SELL
                elif change > threshold:
                    labels.append(2)  # BUY
                else:
                    labels.append(1)  # HOLD
            
            # Ajustar DataFrame
            df = df.iloc[:-pred_periods].copy()
            df['label'] = labels
            
            # Verificar distribuci√≥n
            label_counts = Counter(labels)
            total = len(labels)
            
            print("üìä Distribuci√≥n inicial:")
            for i, name in enumerate(self.class_names):
                count = label_counts[i]
                pct = count / total * 100
                print(f"   - {name}: {count} ({pct:.1f}%)")
            
            # VERIFICAR REQUISITOS M√çNIMOS
            min_samples = self.min_samples_per_class
            needs_adjustment = False
            
            for i, name in enumerate(self.class_names):
                if label_counts[i] < min_samples:
                    print(f"‚ö†Ô∏è {name} tiene solo {label_counts[i]} muestras (m√≠n: {min_samples})")
                    needs_adjustment = True
            
            # Si necesita ajuste, reducir threshold
            if needs_adjustment:
                print("üîß Ajustando threshold para mejor balance...")
                threshold = threshold * 0.7
                
                labels = []
                for change in changes:
                    if change < -threshold:
                        labels.append(0)  # SELL
                    elif change > threshold:
                        labels.append(2)  # BUY
                    else:
                        labels.append(1)  # HOLD
                
                df['label'] = labels
                label_counts = Counter(labels)
                
                print(f"üéØ Nuevo threshold: {threshold*100:.1f}%")
                print("üìä Nueva distribuci√≥n:")
                for i, name in enumerate(self.class_names):
                    count = label_counts[i]
                    pct = count / total * 100
                    print(f"   - {name}: {count} ({pct:.1f}%)")
            
            # Bias score
            percentages = [label_counts[i]/total for i in range(3)]
            label_bias = (max(percentages) - min(percentages)) * 10
            print(f"üìè Label Bias: {label_bias:.1f}/10")
            
            # Guardar threshold usado
            self.final_threshold = threshold
            
            return df, label_bias
            
        except Exception as e:
            print(f"‚ùå Error: {e}")
            return None, None
    
    def prepare_trading_data(self, df):
        """Preparar datos para trading"""
        try:
            print(f"\nüìã PREPARANDO DATOS PARA TRADING")
            print("-" * 40)
            
            # Normalizar features
            scaler = StandardScaler()
            X_scaled = scaler.fit_transform(df[self.features])
            y = np.array(df['label'])
            
            # Crear directorio
            os.makedirs('models/eth_trading', exist_ok=True)
            
            # Guardar scaler
            with open('models/eth_trading/scaler.pkl', 'wb') as f:
                pickle.dump(scaler, f)
            
            print(f"‚úÖ Datos trading: X{X_scaled.shape}, y{y.shape}")
            
            # Verificar distribuci√≥n final
            final_counts = Counter(y)
            total = len(y)
            print("üìä Distribuci√≥n final:")
            for i, name in enumerate(self.class_names):
                count = final_counts[i]
                pct = count / total * 100
                print(f"   - {name}: {count} ({pct:.1f}%)")
            
            return X_scaled, y
            
        except Exception as e:
            print(f"‚ùå Error: {e}")
            return None, None
    
    def create_trading_model(self):
        """Crear modelo optimizado para trading"""
        try:
            print(f"\nüìã MODELO OPTIMIZADO PARA TRADING")
            print("-" * 40)
            
            n_features = len(self.features)
            
            # Arquitectura optimizada para trading
            model = tf.keras.Sequential([
                tf.keras.layers.Input(shape=(n_features,)),
                
                # Primera capa: detecci√≥n de patrones
                tf.keras.layers.Dense(32, activation='relu'),
                tf.keras.layers.BatchNormalization(),
                tf.keras.layers.Dropout(0.3),
                
                # Segunda capa: refinamiento
                tf.keras.layers.Dense(16, activation='relu'),
                tf.keras.layers.Dropout(0.2),
                
                # Tercera capa: decisi√≥n
                tf.keras.layers.Dense(8, activation='relu'),
                tf.keras.layers.Dropout(0.1),
                
                # Output: 3 se√±ales de trading
                tf.keras.layers.Dense(3, activation='softmax')
            ])
            
            # Optimizador con learning rate adaptativo
            optimizer = tf.keras.optimizers.legacy.Adam(
                learning_rate=0.001,
                beta_1=0.9,
                beta_2=0.999
            )
            
            model.compile(
                optimizer=optimizer,
                loss='sparse_categorical_crossentropy',
                metrics=['accuracy']
            )
            
            print(f"‚úÖ Modelo trading: {model.count_params()} par√°metros")
            
            return model
            
        except Exception as e:
            print(f"‚ùå Error: {e}")
            return None
    
    def train_for_trading(self, model, X, y):
        """Entrenar espec√≠ficamente para trading"""
        try:
            print(f"\nüìã ENTRENAMIENTO PARA TRADING")
            print("-" * 40)
            
            # Class weights balanceados
            unique_classes = np.unique(y)
            class_weights = compute_class_weight(
                class_weight='balanced',
                classes=unique_classes,
                y=y
            )
            
            # Ajustar weights para favorecer BUY/SELL
            class_weight_dict = dict(zip(unique_classes, class_weights))
            
            # Boost signals de trading (SELL y BUY)
            if 0 in class_weight_dict:  # SELL
                class_weight_dict[0] *= 1.2
            if 2 in class_weight_dict:  # BUY
                class_weight_dict[2] *= 1.2
            
            print("‚öñÔ∏è Class weights optimizados:")
            for cls, weight in class_weight_dict.items():
                print(f"   - {self.class_names[cls]}: {weight:.3f}")
            
            # Split temporal
            split_idx = int(len(X) * 0.8)
            X_train, X_val = X[:split_idx], X[split_idx:]
            y_train, y_val = y[:split_idx], y[split_idx:]
            
            print(f"üìä Train: {len(X_train)}, Val: {len(X_val)}")
            
            # Callbacks para trading
            callbacks = [
                tf.keras.callbacks.EarlyStopping(
                    monitor='val_accuracy',  # Monitor accuracy para trading
                    patience=25,
                    restore_best_weights=True,
                    verbose=1
                ),
                tf.keras.callbacks.ReduceLROnPlateau(
                    monitor='val_accuracy',
                    factor=0.8,
                    patience=10,
                    min_lr=0.00001,
                    verbose=1
                )
            ]
            
            print("üî• Entrenando para trading...")
            
            # Entrenar
            history = model.fit(
                X_train, y_train,
                validation_data=(X_val, y_val),
                epochs=150,  # M√°s √©pocas para mejor aprendizaje
                batch_size=16,
                class_weight=class_weight_dict,
                callbacks=callbacks,
                verbose=1
            )
            
            # Evaluar con enfoque trading
            predictions = model.predict(X_val, verbose=0)
            pred_classes = np.argmax(predictions, axis=1)
            
            # Distribuci√≥n final
            pred_counts = Counter(pred_classes)
            total_preds = len(pred_classes)
            
            print(f"\nüìä PREDICCIONES TRADING:")
            for i, name in enumerate(self.class_names):
                count = pred_counts[i]
                pct = count / total_preds * 100
                print(f"   - {name}: {count} ({pct:.1f}%)")
            
            # M√©tricas trading
            percentages = [pred_counts[i]/total_preds for i in range(3)]
            final_bias = (max(percentages) - min(percentages)) * 10
            avg_confidence = np.mean(np.max(predictions, axis=1))
            
            print(f"\nüéØ M√âTRICAS TRADING:")
            print(f"   üìè Bias Score: {final_bias:.1f}/10")
            print(f"   üéØ Confianza: {avg_confidence:.3f}")
            
            # Accuracy por se√±al
            print(f"\nüéØ ACCURACY POR SE√ëAL:")
            trading_ready = True
            
            for i, name in enumerate(self.class_names):
                mask = y_val == i
                if np.sum(mask) > 0:
                    class_pred = pred_classes[mask]
                    class_acc = np.mean(class_pred == i)
                    print(f"   - {name}: {class_acc:.3f}")
                    
                    # Verificar requisitos m√≠nimos
                    if class_acc < 0.3:  # M√≠nimo 30%
                        trading_ready = False
                        print(f"     ‚ö†Ô∏è Bajo para trading real")
                    else:
                        print(f"     ‚úÖ Apto para trading")
            
            # Verificar si cumple requisitos trading
            print(f"\nüîç VERIFICACI√ìN TRADING READY:")
            print(f"   üìä Predice 3 se√±ales: {'‚úÖ' if all(pred_counts[i] > 0 for i in range(3)) else '‚ùå'}")
            print(f"   üìè Bias < 5.0: {'‚úÖ' if final_bias < 5.0 else '‚ùå'}")
            print(f"   üéØ Confianza > 0.6: {'‚úÖ' if avg_confidence > 0.6 else '‚ùå'}")
            print(f"   üéØ Accuracy > 0.3: {'‚úÖ' if trading_ready else '‚ùå'}")
            
            return final_bias, pred_counts, avg_confidence, trading_ready
            
        except Exception as e:
            print(f"‚ùå Error: {e}")
            return None, None, None, False
    
    def save_trading_model(self, model, bias_score, pred_counts, avg_confidence, trading_ready):
        """Guardar modelo trading"""
        try:
            print(f"\nüìã GUARDANDO MODELO TRADING")
            print("-" * 40)
            
            model_path = 'models/eth_trading/eth_trading_model.h5'
            model.save(model_path)
            
            metadata = {
                'pair': self.pair_symbol,
                'model_type': 'ETH Trading Ready Model',
                'features': self.features,
                'threshold': float(self.final_threshold),
                'prediction_periods': self.prediction_periods,
                'bias_score': float(bias_score),
                'avg_confidence': float(avg_confidence),
                'trading_ready': trading_ready,
                'final_distribution': {
                    'SELL': float(pred_counts[0]/sum(pred_counts.values())),
                    'HOLD': float(pred_counts[1]/sum(pred_counts.values())),
                    'BUY': float(pred_counts[2]/sum(pred_counts.values()))
                },
                'training_date': datetime.now().isoformat(),
                'model_params': model.count_params()
            }
            
            with open('models/eth_trading/metadata.json', 'w') as f:
                json.dump(metadata, f, indent=2)
            
            print(f"‚úÖ Modelo guardado: {model_path}")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Error: {e}")
            return False
    
    def train_complete(self):
        """Entrenamiento completo para trading"""
        print("üéØ ENTRENAMIENTO ETH TRADING READY")
        print("="*60)
        
        # 1. Datos optimizados
        df = self.get_optimized_data()
        if df is None:
            return False
        
        # 2. Labels balanceadas
        df, label_bias = self.create_balanced_labels(df)
        if df is None:
            return False
        
        # 3. Preparar datos
        X, y = self.prepare_trading_data(df)
        if X is None:
            return False
        
        # 4. Modelo trading
        model = self.create_trading_model()
        if model is None:
            return False
        
        # 5. Entrenar para trading
        final_bias, pred_counts, avg_confidence, trading_ready = self.train_for_trading(model, X, y)
        if final_bias is None:
            return False
        
        # 6. Guardar
        if not self.save_trading_model(model, final_bias, pred_counts, avg_confidence, trading_ready):
            return False
        
        # Resultado final
        print(f"\nüèÜ RESULTADO ETH TRADING:")
        print(f"   üìè Bias Score: {final_bias:.1f}/10")
        print(f"   üéØ Confianza: {avg_confidence:.3f}")
        print(f"   üöÄ Trading Ready: {'‚úÖ S√ç' if trading_ready else '‚ùå NO'}")
        
        if trading_ready:
            print("üéâ ¬°MODELO ETH LISTO PARA TRADING REAL!")
            return True
        else:
            print("‚ö†Ô∏è Modelo funcional pero necesita optimizaci√≥n")
            return False


if __name__ == "__main__":
    trainer = ETHTradingReady()
    success = trainer.train_complete()
    
    if success:
        print("\nüéâ ¬°ETH TRADING READY COMPLETADO!")
    else:
        print("\n‚ùå ETH requiere m√°s optimizaci√≥n") 