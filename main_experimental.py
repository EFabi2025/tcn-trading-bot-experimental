#!/usr/bin/env python3
"""
üß™ EXPERIMENTAL TCN Trading Bot - Research Tool

Bot de trading experimental para investigaci√≥n algor√≠tmica que:
- Usa modelo TCN (Temporal Convolutional Network) real
- Puede operar en modo simulaci√≥n O trading real
- Integra con Binance API (testnet y mainnet)
- Implementa estrategias de ML para an√°lisis de mercado

üö® EXPERIMENTAL: Para investigaci√≥n en trading algor√≠tmico
Configure cuidadosamente el modo de operaci√≥n en .env

Modos disponibles:
1. SIMULACI√ìN: dry_run=true - Solo an√°lisis, sin trades reales
2. TESTNET: dry_run=false + testnet=true - Trading real en testnet
3. PRODUCCI√ìN: dry_run=false + testnet=false - Trading real en mainnet

‚ö†Ô∏è ADVERTENCIA: Modo producci√≥n usa dinero real
"""

import asyncio
import signal
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Any, Optional

import structlog
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from rich.table import Table
from rich.live import Live
from rich.layout import Layout

# Configurar el path para imports
sys.path.append(str(Path(__file__).parent))

from src.core.config import TradingBotSettings
from src.core.logging_config import TradingLogger
from src.core.service_factory import ExperimentalServiceFactory
from src.interfaces.trading_interfaces import ITradingOrchestrator

console = Console()
logger = structlog.get_logger(__name__)


class ExperimentalTradingBot:
    """
    üß™ Bot de Trading Experimental
    
    Sistema completo para investigaci√≥n en trading algor√≠tmico
    con modelo TCN y configuraci√≥n flexible de seguridad
    """
    
    def __init__(self):
        self.settings: Optional[TradingBotSettings] = None
        self.trading_logger: Optional[TradingLogger] = None
        self.service_factory: Optional[ExperimentalServiceFactory] = None
        self.orchestrator: Optional[ITradingOrchestrator] = None
        self.is_running = False
        
        # Setup signal handlers
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def _signal_handler(self, signum, frame):
        """Handle shutdown signals gracefully"""
        console.print("\nüõë Se√±al de interrupci√≥n recibida. Cerrando sistema...", style="bold yellow")
        self.is_running = False
    
    async def initialize(self) -> None:
        """
        üß™ Inicializa el sistema experimental
        """
        try:
            # 1. Cargar configuraci√≥n
            self.settings = TradingBotSettings()
            
            # 2. Configurar logging
            self.trading_logger = TradingLogger()
            
            # 3. Mostrar configuraci√≥n
            self._display_configuration()
            
            # 4. Validar y confirmar configuraci√≥n
            if not await self._confirm_configuration():
                console.print("‚ùå Configuraci√≥n cancelada por el usuario", style="bold red")
                return
            
            # 5. Crear servicios
            self.service_factory = ExperimentalServiceFactory(
                settings=self.settings,
                trading_logger=self.trading_logger
            )
            
            # 6. Validar configuraci√≥n experimental
            validation = self.service_factory.validate_experimental_config()
            self._display_validation_results(validation)
            
            if not validation['config_valid']:
                console.print("‚ùå Configuraci√≥n inv√°lida. Revise los errores.", style="bold red")
                return
            
            # 7. Crear orquestador
            self.orchestrator = self.service_factory.create_trading_orchestrator()
            
            console.print("‚úÖ Sistema experimental inicializado correctamente", style="bold green")
            
        except Exception as e:
            console.print(f"‚ùå Error inicializando sistema: {e}", style="bold red")
            logger.error("initialization_failed", error=str(e))
            raise
    
    def _display_configuration(self) -> None:
        """Muestra la configuraci√≥n actual"""
        # Determinar el modo de operaci√≥n
        if self.settings.dry_run:
            mode = "üß™ SIMULACI√ìN"
            mode_style = "green"
            description = "Solo an√°lisis - No ejecuta trades reales"
        elif self.settings.binance_testnet:
            mode = "üî¨ TESTNET"
            mode_style = "yellow"
            description = "Trading real en testnet de Binance"
        else:
            mode = "üö® PRODUCCI√ìN"
            mode_style = "red"
            description = "Trading REAL con dinero REAL en Binance"
        
        # Crear tabla de configuraci√≥n
        table = Table(title="üß™ Configuraci√≥n Experimental del Bot")
        table.add_column("Par√°metro", style="cyan", no_wrap=True)
        table.add_column("Valor", style="magenta")
        table.add_column("Descripci√≥n", style="dim")
        
        table.add_row("Modo", f"[{mode_style}]{mode}[/{mode_style}]", description)
        table.add_row("Entorno", self.settings.environment, "Entorno de ejecuci√≥n")
        table.add_row("S√≠mbolo", ", ".join(self.settings.trading_symbols), "Pares de trading")
        table.add_row("Intervalo", f"{self.settings.trading_interval_seconds}s", "Frecuencia de an√°lisis")
        table.add_row("Max Posici√≥n", f"{self.settings.max_position_percent}%", "% m√°ximo del portafolio")
        table.add_row("Max P√©rdida Diaria", f"{self.settings.max_daily_loss_percent}%", "% m√°ximo de p√©rdida diaria")
        
        console.print(table)
    
    async def _confirm_configuration(self) -> bool:
        """Confirma la configuraci√≥n con el usuario"""
        if self.settings.dry_run:
            # En modo simulaci√≥n, confirmar autom√°ticamente
            console.print("‚úÖ Modo simulaci√≥n - Contin√∫o autom√°ticamente", style="bold green")
            return True
        
        # En modos con trading real, requerir confirmaci√≥n expl√≠cita
        console.print("\n‚ö†Ô∏è  CONFIRMACI√ìN REQUERIDA", style="bold yellow")
        
        if self.settings.binance_testnet:
            message = "¬øConfirma ejecutar trading REAL en TESTNET de Binance?"
        else:
            message = "üö® ¬øConfirma ejecutar trading REAL en PRODUCCI√ìN con DINERO REAL?"
            console.print("üí∞ ADVERTENCIA: Esto usar√° dinero real de su cuenta de Binance", style="bold red")
        
        while True:
            response = input(f"\n{message} (s√≠/no): ").lower().strip()
            if response in ['s√≠', 'si', 'yes', 'y', 's']:
                return True
            elif response in ['no', 'n']:
                return False
            else:
                console.print("Por favor responda 's√≠' o 'no'", style="yellow")
    
    def _display_validation_results(self, validation: Dict[str, Any]) -> None:
        """Muestra resultados de validaci√≥n"""
        if validation['config_valid']:
            console.print("‚úÖ Configuraci√≥n v√°lida", style="bold green")
        else:
            console.print("‚ùå Configuraci√≥n inv√°lida", style="bold red")
        
        if validation['warnings']:
            console.print("\n‚ö†Ô∏è  Advertencias:", style="bold yellow")
            for warning in validation['warnings']:
                console.print(f"  ‚Ä¢ {warning}", style="yellow")
        
        if validation['research_notes']:
            console.print("\nüìã Notas de configuraci√≥n:", style="bold blue")
            for note in validation['research_notes']:
                console.print(f"  ‚Ä¢ {note}", style="blue")
    
    async def run_continuous_trading(self) -> None:
        """
        üîÑ Ejecuta trading continuo experimental
        """
        if not self.orchestrator:
            raise RuntimeError("Sistema no inicializado")
        
        console.print("üöÄ Iniciando trading continuo experimental...", style="bold green")
        self.is_running = True
        
        try:
            # Layout para display en vivo
            layout = Layout()
            layout.split_column(
                Layout(Panel(Text("üìä TCN Trading Bot Experimental", justify="center", style="bold blue"))),
                Layout(name="main"),
                Layout(Panel(Text("Presione Ctrl+C para detener", justify="center", style="dim")), size=3)
            )
            
            with Live(layout, refresh_per_second=1) as live:
                cycle_count = 0
                
                while self.is_running:
                    cycle_count += 1
                    
                    try:
                        # Actualizar display
                        self._update_live_display(layout, cycle_count)
                        
                        # Ejecutar ciclo de trading
                        results = await self.orchestrator.execute_trading_cycle()
                        
                        # Log resultados
                        self.trading_logger.log_trading_cycle_completed(
                            results.dict(),
                            research_note=f"Ciclo {cycle_count} completado"
                        )
                        
                        # Esperar hasta el siguiente ciclo
                        await asyncio.sleep(self.settings.trading_interval_seconds)
                        
                    except KeyboardInterrupt:
                        break
                    except Exception as e:
                        logger.error("trading_cycle_error", cycle=cycle_count, error=str(e))
                        console.print(f"‚ùå Error en ciclo {cycle_count}: {e}", style="red")
                        await asyncio.sleep(5)  # Esperar antes de reintentar
        
        except Exception as e:
            logger.error("continuous_trading_failed", error=str(e))
            console.print(f"‚ùå Error en trading continuo: {e}", style="bold red")
        
        finally:
            console.print("üõë Trading continuo detenido", style="bold yellow")
    
    def _update_live_display(self, layout: Layout, cycle_count: int) -> None:
        """Actualiza el display en vivo"""
        # Obtener status de servicios
        status = self.service_factory.get_service_status()
        
        # Crear tabla de status
        status_table = Table(title=f"Status del Sistema - Ciclo {cycle_count}")
        status_table.add_column("Servicio", style="cyan")
        status_table.add_column("Estado", style="green")
        status_table.add_column("Tiempo", style="dim")
        
        for service, is_ok in status.items():
            estado = "‚úÖ OK" if is_ok else "‚ùå Error"
            status_table.add_row(service, estado, datetime.now(timezone.utc).strftime("%H:%M:%S"))
        
        layout["main"].update(Panel(status_table))
    
    async def run_manual_analysis(self) -> None:
        """
        üîç Ejecuta an√°lisis manual experimental
        """
        if not self.orchestrator:
            raise RuntimeError("Sistema no inicializado")
        
        console.print("üîç Ejecutando an√°lisis manual experimental...", style="bold blue")
        
        try:
            for symbol in self.settings.trading_symbols:
                console.print(f"\nüìä Analizando {symbol}...", style="cyan")
                
                # Ejecutar an√°lisis
                results = await self.orchestrator.analyze_symbol(symbol)
                
                # Mostrar resultados
                self._display_analysis_results(symbol, results)
                
                # Log resultados
                self.trading_logger.log_analysis_completed(
                    symbol,
                    results.dict(),
                    research_note="An√°lisis manual experimental"
                )
        
        except Exception as e:
            logger.error("manual_analysis_failed", error=str(e))
            console.print(f"‚ùå Error en an√°lisis manual: {e}", style="bold red")
    
    def _display_analysis_results(self, symbol: str, results: Dict[str, Any]) -> None:
        """Muestra resultados de an√°lisis"""
        table = Table(title=f"An√°lisis de {symbol}")
        table.add_column("M√©trica", style="cyan")
        table.add_column("Valor", style="magenta")
        
        # Mostrar datos b√°sicos del an√°lisis
        for key, value in results.items():
            if isinstance(value, (int, float, str)):
                table.add_row(str(key), str(value))
        
        console.print(table)
    
    async def shutdown(self) -> None:
        """
        üõë Cierra el sistema experimental ordenadamente
        """
        console.print("üõë Cerrando sistema experimental...", style="bold yellow")
        
        try:
            if self.service_factory:
                await self.service_factory.cleanup_services()
            
            if self.trading_logger:
                self.trading_logger.log_system_event(
                    "experimental_bot_shutdown",
                    research_note="Sistema experimental cerrado correctamente"
                )
            
            console.print("‚úÖ Sistema cerrado correctamente", style="bold green")
        
        except Exception as e:
            logger.error("shutdown_error", error=str(e))
            console.print(f"‚ùå Error durante cierre: {e}", style="red")


async def main():
    """
    üöÄ Funci√≥n principal experimental
    """
    console.print("üß™ TCN Trading Bot Experimental", style="bold blue")
    console.print("Para investigaci√≥n en trading algor√≠tmico\n", style="dim")
    
    bot = ExperimentalTradingBot()
    
    try:
        # Inicializar sistema
        await bot.initialize()
        
        if not bot.orchestrator:
            console.print("‚ùå Sistema no se pudo inicializar", style="bold red")
            return
        
        # Men√∫ principal
        while True:
            console.print("\nüß™ Men√∫ Experimental:")
            console.print("1. üîÑ Trading continuo (autom√°tico)")
            console.print("2. üîç An√°lisis manual")
            console.print("3. üìä Ver estado del sistema")
            console.print("4. üõë Salir")
            
            try:
                choice = input("\nSeleccione una opci√≥n: ").strip()
                
                if choice == "1":
                    await bot.run_continuous_trading()
                elif choice == "2":
                    await bot.run_manual_analysis()
                elif choice == "3":
                    status = bot.service_factory.get_service_status()
                    console.print(f"\nüìä Estado del sistema: {status}")
                elif choice == "4":
                    break
                else:
                    console.print("‚ùå Opci√≥n inv√°lida", style="red")
            
            except KeyboardInterrupt:
                break
            except Exception as e:
                console.print(f"‚ùå Error: {e}", style="red")
                logger.error("menu_error", error=str(e))
    
    except Exception as e:
        console.print(f"‚ùå Error cr√≠tico: {e}", style="bold red")
        logger.error("critical_error", error=str(e))
    
    finally:
        await bot.shutdown()


if __name__ == "__main__":
    # Configurar logging
    import logging
    logging.basicConfig(level=logging.INFO)
    
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        console.print("\nüëã Bot experimental detenido por el usuario", style="bold yellow")
    except Exception as e:
        console.print(f"\nüí• Error cr√≠tico: {e}", style="bold red")
        sys.exit(1) 